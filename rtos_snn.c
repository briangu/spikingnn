#include <stdlib.h>
#include <stdio.h>
#include <math.h>

// These defines effect values everywhere and the majority of the program will adjust when these are changes
// The two sections that will not adjust is the membrane potential update and the sensor update, please be aware of this
#define numneuron 8
#define numsensor 15 // Bits of Sensor
#define numindivid 6

unsigned int i, j, k, x, a, b, c, d, e, f, y, z, g, h, ii, jj, kk, xx, yy, zz;

// Task variables
unsigned char sensorflag; // Flag that indicates Sensors have been updated (1 updated, 0 not updated)
unsigned char evolveflag; // Flag that indicates a mutation has just occurred

// Neuron Variables
unsigned char individual; // Currently Selected Individual of the population (0 - 5)
unsigned char neuron; // Output of Neurons (1 is spike, 0 is no spike), ie. 0b11001100 means neurons 2, 3, 6, 7 are spiking, neurons 0, 1, 4, 5 are not
unsigned int sensor; // Output of Sensors (1 is spike, 0 is no spike), ie. 0b11001100 means sensors 2, 3, 6, 7 are spiking, sensors 0, 1, 4, 5 are not
unsigned char signs[numindivid]; // Sign of Neurons (1 is positive, 0 is negative), ie. 0b00001111 means neurons 0, 1, 2, 3 are positive, neurons 4, 5, 6, 7 are not
unsigned char nconnection[numindivid][numneuron]; // Connections from Neurons, each char describes connections for one neuron (1 is connection, 0 is no connection), ie. 0b11001010 means there are connections to this neuron from neurons 1, 3, 6, 7 and no connection from neurons 0, 2, 4, 5
unsigned int sconnection[numindivid][numneuron]; // Connections from Sensors, each char describes connections from one sensor (1 is connection, 0 is no connection) to each neuron
signed int memb[numneuron]; // Membrane Potential of each Neuron (minimum value of 0, initialized to 0)
float fitness[numindivid]; // Fitness value for an individual
unsigned int threshold[numindivid]; // Membrane Threshold (5) - DEBUG BEING SET TO EVOLVE RANDOMLY BETWEEN 2 AND 6
unsigned char leaking; // Leaking Constant (1)
unsigned char minimum; // Miminum Membrane Potential (0)
unsigned int randomint; // Randomly generated integer

// Old Variables
unsigned char oldsigns;
unsigned char oldnconnection[numneuron];
unsigned int oldsconnection[numneuron];
unsigned int oldthreshold;

// ADC Variables
unsigned int Ain; // Current ADC input
unsigned int Ain2; // DEBUG for Noise for ADCL
float voltage; // Current ADC input converted into voltage
unsigned int sensorread; // Values of Sensors being read
float probability; // Probability of getting a random noise spike
float randomprob; // Random probability

// Motor Variables
unsigned char stepL; // Step variable for Left Motor
unsigned char stepR; // Step variable for Right Motor
unsigned char dirL; // Direction variable for Left Motor (0 Forward or 1 Backward)
unsigned char dirR; // Direction variable for Right Motor (0 Forward or 1 Backward)
unsigned char spikeFL; // Number of spikes during sensor update period (20 ms) generated by forward left neuron
unsigned char totalspikeFL; // Total spikes between evolution
unsigned char spikeBL; // Number of spikes during sensor update period (20 ms) generated by backward left neuron
unsigned char totalspikeBL; // Total spikes between evolution
unsigned char spikeFR; // Number of spikes during sensor update period (20 ms) generated by forward right neuron
unsigned char totalspikeFR; // Total spikes between evolution
unsigned char spikeBR; // Number of spikes during sensor update period (20 ms) generated by backward right neuron
unsigned char totalspikeBR; // Total spikes between evolution
unsigned long maxspikes; // Number of possible spikes during sensor update period
float v2, v3; // Motor Velocities

// Evolution Variables
float newfitness; // Calculates new fitness to compare with old fitnesses
unsigned char keep; // Keep determines if we will keep a mutation, is 1 if it the current individuals fitness is >= worst individuals fitness
unsigned char collision; // Indicates a collision for fitness calculation (0 is no collision, 1 collision)
float sensormaxactivity; // Most active sensor value for fitness calculation (5 values for this based on most active sensor: 0 if nothing, .25 if between top and mid, .5 if between mid and bot, .75 if between bot and col, 1 if below or equal to col)
float sensoractivity[numsensor / 3]; // Activity of 5 sensors based on values above to be maxed
unsigned char worstindivid; // Worst indiviudal used to determine keep
unsigned char randn, rands; // Random Variables to access blocks in random individual for mutation
unsigned int randomseed;
float change; // Change in fitness (debugging)

// Fitness Store variables
unsigned int bestfitness; // Best Fitness so far
unsigned int bestindivid; // Best Individual

void generateRandomSeed() {
  //randomseed = randomseed/(numsensor/3);
  randomseed = 0;
  srand(randomseed);
}

int mapRand() {
  return ((rand() % 5) - 2); // scale to [-2,2]
}

void addSpikeToNeuralNetwork() {
  memb[0] = threshold[individual] + 20;
  memb[2] = threshold[individual] + 20;
  // Debugging
  //memb[4] = threshold[individual] + 20;
  //memb[5] = threshold[individual] + 20;
  //memb[6] = threshold[individual] + 20;
  //memb[7] = threshold[individual] + 20;
}

////////////////////////////////////////////////////////////////
void iterateNeuralNetwork(void) {
  // Sensor/Motor Updating
  if (sensorflag == 0) {
    sensor = 0; // If sensors aren't ready, sensor nodes shouldn't be spiking
  } else {
    sensor = sensorread;
    sensorflag = 0;
    spikeFL = 0;
    spikeBL = 0;
    spikeFR = 0;
    spikeBR = 0;
    maxspikes = 0;
  }

  if (evolveflag == 1) { // If just evolved
    // Spike Forward Motor Neurons to start
    addSpikeToNeuralNetwork();

    evolveflag = 0;

    totalspikeFL = 0;
    totalspikeBL = 0;
    totalspikeFR = 0;
    totalspikeBR = 0;
  }

  // Debugging
  printf("%x\n\r", neuron);
  //////////////Refractory Period/Contribution of Incoming Spikes/Membrane Potential Update//////////////
  for (i = 0; i < numneuron; i++) {
    // Refractory Period Check (if spike generated in previous update, don't update membrane potential)
    if (((neuron >> i) & 0x01) == 0) {
      // Calculate Contribution of Sensors and update membrane potential
      memb[i] = (memb[i] +
        (((sensor & sconnection[individual][i]) & 0b10000000) >> 7) +
        (((sensor & sconnection[individual][i]) & 0b01000000) >> 6) +
        (((sensor & sconnection[individual][i]) & 0b00100000) >> 5) +
        (((sensor & sconnection[individual][i]) & 0b00010000) >> 4) +
        (((sensor & sconnection[individual][i]) & 0b00001000) >> 3) +
        (((sensor & sconnection[individual][i]) & 0b00000100) >> 2) +
        (((sensor & sconnection[individual][i]) & 0b00000010) >> 1) +
        (((sensor & sconnection[individual][i]) & 0b00000001) >> 0));

      // Calculate Contribution of Positive Neurons and update membrane potential
      memb[i] = (memb[i] +
        (((neuron & signs[individual] & nconnection[individual][i]) & 0b10000000) >> 7) +
        (((neuron & signs[individual] & nconnection[individual][i]) & 0b01000000) >> 6) +
        (((neuron & signs[individual] & nconnection[individual][i]) & 0b00100000) >> 5) +
        (((neuron & signs[individual] & nconnection[individual][i]) & 0b00010000) >> 4) +
        (((neuron & signs[individual] & nconnection[individual][i]) & 0b00001000) >> 3) +
        (((neuron & signs[individual] & nconnection[individual][i]) & 0b00000100) >> 2) +
        (((neuron & signs[individual] & nconnection[individual][i]) & 0b00000010) >> 1) +
        (((neuron & signs[individual] & nconnection[individual][i]) & 0b00000001) >> 0));

      // Calculate Contribution of Negative Neurons and update membrane potential
      memb[i] = (memb[i] -
        (((neuron & ((~signs[individual]) & 0xFF) & nconnection[individual][i]) & 0b10000000) >> 7) -
        (((neuron & ((~signs[individual]) & 0xFF) & nconnection[individual][i]) & 0b01000000) >> 6) -
        (((neuron & ((~signs[individual]) & 0xFF) & nconnection[individual][i]) & 0b00100000) >> 5) -
        (((neuron & ((~signs[individual]) & 0xFF) & nconnection[individual][i]) & 0b00010000) >> 4) -
        (((neuron & ((~signs[individual]) & 0xFF) & nconnection[individual][i]) & 0b00001000) >> 3) -
        (((neuron & ((~signs[individual]) & 0xFF) & nconnection[individual][i]) & 0b00000100) >> 2) -
        (((neuron & ((~signs[individual]) & 0xFF) & nconnection[individual][i]) & 0b00000010) >> 1) -
        (((neuron & ((~signs[individual]) & 0xFF) & nconnection[individual][i]) & 0b00000001) >> 0));

      // Minumimum of memb is 0
      if (memb[i] < minimum) {
        memb[i] = minimum;
      }
    }
  }

  ///////////////////////////////////////////Spike Generation////////////////////////////////////////////
  for (j = 0; j < numneuron; j++) {
    randomint = mapRand();

    if (memb[j] >= (threshold[individual] + randomint)) {
      neuron = (neuron | (1 << j));
      memb[j] = minimum;
    } else {
      neuron = (neuron & (~(1 << j)));
    }
  }

  printf("%x\n\r", neuron);

  //////////////////////////////////////////Motor Spike//////////////////////////////////////////////////
  // 1st neuron is left forward motor, 2nd is left backward motor, 3rd if right forward motor, 4th is right backward motor
  // If spiking add to total number of spikes
  if ((neuron & 0x01) == 1) {
    spikeFL++;
    totalspikeFL++;
  }
  if ((neuron & 0x02) == 2) {
    spikeBL++;
    totalspikeBL++;
  }
  if ((neuron & 0x04) == 4) {
    spikeFR++;
    totalspikeFR++;
  }
  if ((neuron & 0x08) == 8) {
    spikeBR++;
    totalspikeBR++;
  }

  maxspikes++;

  printf("%x %i %i %i %i\n\r", neuron, spikeFL, spikeBL, spikeFR, spikeBR);
  ///////////////////////////////////////////Leakage/////////////////////////////////////////////////////
  for (k = 0; k < numneuron; k++) {
    if ((memb[k] - leaking) >= minimum) {
      memb[k] = memb[k] - leaking;
    } else {
      memb[k] = minimum;
    }
  }
}

////////////////////////////////////////////////////////////////
void initialize(void) {
  // Generate Random Seed
  generateRandomSeed();

  sensorflag = 0;
  evolveflag = 0; // Flag that indicates a mutation has just occurred

  // Neuron Variables
  neuron = 0; // Output of Neurons (1 is spike, 0 is no spike), ie. 0b11001100 means neurons 2, 3, 6, 7 are spiking, sensors 0, 1, 4, 5 are not
  sensor = 0; // Output of Sensors (1 is spike, 0 is no spike), ie. 0b11001100 means sensors 2, 3, 6, 7 are spiking, sensors 0, 1, 4, 5 are not
  individual = (rand() % (numindivid)); // Current Individual (0 - 5)

  // The population will be initialized using random numbers and all fitness values will be set to zero
  // Use EEPROM if already started a population
  for (b = 0; b < numindivid; b++) {
    signs[b] = (rand() % (1 << numneuron)); // Sign of Neurons (1 is positive, 0 is negative), ie. 0b00001111 means neurons 0, 1, 2, 3 are positive, neurons 4, 5, 6, 7 are not
    // Debugging
    printf("%x\n\r", signs[b]);
    for (a = 0; a < numneuron; a++) {
      nconnection[b][a] = (rand() % (1 << numneuron)); // Connections from Neurons, each char describes connections for one neuron (1 is connection, 0 is no connection), ie. 0b11001010 means there are connections to this neuron from neurons 1, 3, 6, 7 and no connection from neurons 0, 2, 4, 5
      sconnection[b][a] = (rand() % (1 << numsensor)); // Connections from Sensors, each char describes connections from one sensor (1 is connection, 0 is no connection)
      memb[a] = 0; // Membrane Potential of each Neuron (minimum value of 0, initialized to 0)
    }
    // Debugging
    printf("%x\n\r", sconnection[b][0]);
    fitness[b] = 0; // Fitness value for an individual
    threshold[b] = (rand() % 4 + 3); // Membrane Threshold (5)
  }
  leaking = 1; // Leaking Constant (1)
  minimum = 0; // Miminum Membrane Potential (0)
  randomint = 0; // Randomly generated integer

  // Spike Forward Motor Neurons to start
  addSpikeToNeuralNetwork();

  // Old Values
  oldsigns = signs[individual];
  for (c = 0; c < numneuron; c++) {
    oldnconnection[c] = nconnection[individual][c];
    oldsconnection[c] = sconnection[individual][c];
  }
  oldthreshold = 0;

  // ADC Variables
  sensorread = 0; // Values of Sensors being read
  probability = 0; // Probability of getting a random noise spike
  randomprob = 0; // Random probability

  // Motor Variables
  stepL = 0;
  stepR = 0;
  dirL = 0; // Forward
  dirR = 0; // Forward
  spikeFL = 0; // Number of spikes during sensor update period (20 ms) generated by forward left neuron
  totalspikeFL = 0; // Total spikes between evolution
  spikeBL = 0; // Number of spikes during sensor update period (20 ms) generated by backward left neuron
  totalspikeBL = 0; // Total spikes between evolution
  spikeFR = 0; // Number of spikes during sensor update period (20 ms) generated by forward right neuron
  totalspikeFR = 0; // Total spikes between evolution
  spikeBR = 0; // Number of spikes during sensor update period (20 ms) generated by backward right neuron
  totalspikeBR = 0; // Total spikes between evolution
  maxspikes = 0; // Number of possible spikes during sensor update period
  v2 = 0; // Motor Velocities
  v3 = 0;

  // Evolution Variables
  newfitness = 0; // Calculates new fitness to compare with old fitnesses
  keep = 0; // Keep determines if we will keep a mutation, is 1 if it the current individuals fitness is >= worst individuals fitness
  collision = 0; // Indicates a collision for fitness calculation (0 no collision, 1 collision)
  sensormaxactivity = 0; // Most active sensor value for fitness calculation (5 values for this based on most active sensor: 0 if nothing, .25 if between top and mid, .5 if between mid and bot, .75 if between bot and col, 1 if below or equal to col)
  for (h = 0; h < (numsensor / 3); h++) {
    sensoractivity[h] = 0; // Activity of 5 sensors based on values above to be maxed
  };
  worstindivid = 0; // Worst indiviudal used to determine keep
  randn = 0; // Random Variables to access blocks in random individual for mutation
  rands = 0;
  change = 0; // Change in fitness (debugging)

  // Fitness Store variables
  bestfitness = 0; // Best Fitness so far
  bestindivid = 0; // Best Individual
  // Print out Current EEPROM Best Individual (if avaliable)
  // Print out Current EEPROM Best Fitness (if avaliable)
}

////////////////////////////////////////////////////////////////
void updateSensors(void) {
  ////////////////////////////////////////Sensor Update//////////////////////////////////////////////////
  collision = 0; // Reset collision before recalculating
  for (x = 1; x <= ((numsensor / 3) + 1); x++) {
  } // Ends for loop for sensor update

  generateRandomSeed();

  // Calculate max sensor actiivty
  sensormaxactivity = sensoractivity[0];
  for (g = 1; g < (numsensor / 3); g++) {
    if (sensoractivity[g] > sensormaxactivity) {
      sensormaxactivity = sensoractivity[g];
    }
  }

  // Debugging
  // This is the way to get the most random bits in, based on noise, will OR with regular senorread to get sensor values when plugged back into robot
  sensorread = (sensorread | (((rand() % 2) << 0) | ((rand() % 2) << 3) | ((rand() % 2) << 6) | ((rand() % 2) << 9) | ((rand() % 2) << 12)));
  //sensorread = (((rand()%2) << 0)|((rand() %2) << 3)|((rand() %2) << 6)|((rand() %2) << 9)|((rand() %2) << 12));
  //collision = 0;
  //sensormaxactivity = 0;
  //printf("%x\n\r", sensorread);

  // Ready sensor and motor update
  sensorflag = 1;
} // Ends task 4


////////////////////////////////////////////////////////////////
void updateMotorSpeed(void) {

  // Only do Motor Speed Update every 160 ms, this allows for max 8 cm/s at least one movemnet since it takes 41ms to execute
  ///////////////////////////////////////Motor Speed Update//////////////////////////////////////////////
  // Motor speed for next 20ms is for each motor: spikesforward-spikesbackward scaled to [-8 cm/s, 8 cm/s]
  // Velocity will be determined by time of each step which is equal to .332485 cm / (spikesforward-spikesbackward)
  // Ie. this is initialized to .332485 cm / 3.32483 cm / s = .1 s = 100 ms
  // Concern here is that time will always be significantly higher than next motor udpate time, risk?
  //printf("%li %li %li %li %ld\n\r", spikeFL, spikeBL, spikeFR, spikeBR, maxspikes);
  if (spikeFL >= spikeBL) // If more forward then back, direction is forward
  {
    // Debugging
    dirL = 0;
    // Multiply by 8.0 since maxspikes is actually maxspikes * 2 since if a neuron does spike it won't spike twice in a row because of the refractory period
    v2 = ((float)((float)((float) spikeFL - (float) spikeBL) / (float) maxspikes) * 2.0 * 8.0);
    // Debugging (comment out t2 change)
    // t2 = (0.332485 / v2 * 1000.0);
    // time2 = t2;
  } else {
    // Debugging
    dirL = 1;
    v2 = ((float)((float)((float) spikeBL - (float) spikeFL) / (float) maxspikes) * 2.0 * 8.0);
    // Debugging
    // t2 = (0.332485 / v2 * 1000.0);
    // time2 = t2;
  }
  if (spikeFR >= spikeBR) // If more forward then back, direction is forward
  {
    // Debugging
    dirR = 0;
    v3 = ((float)((float)((float) spikeFR - (float) spikeBR) / (float) maxspikes) * 2.0 * 8.0);
    // Debugging
    // t3 = (0.332485 / v3 * 1000.0);
    // time3 = t3;
  } else {
    // Debugging
    dirR = 1;
    v3 = ((float)((float)((float) spikeBR - (float) spikeFR) / (float) maxspikes) * 2.0 * 8.0);
    // Debugging
    // t3 = (0.332485 / v3 * 1000.0);
    // time3 = t3;
  } // } Motor Speed update

  // Set tsk4cnt to be the greater of the times 350>tsk4cnt>60
  // if (t2 > t3 && t2 <= 350) {
  //   tsk4cnt = t2 + 10;
  // } else if (t3 > t2 && t3 <= 350) {
  //   tsk4cnt = t3 + 10;
  // } else tsk4cnt = 60;
  //printf("%li %li\n\r", t2, t3);

  // Fitness Calculation
  if (dirL == 0 && dirR == 0 && collision == 0) // As long as going forward on both wheels and no collision
  {
    if (v2 >= v3) {
      newfitness = newfitness + (v2 + v3) * (1.0 - ((v2 - v3) / 8.0)) * (1.0 - (sensormaxactivity)); // Need to add something to sensor
      //change = (v2+v3)*(1.0-((v2-v3)/8.0))*(1.0-(sensormaxactivity));
      //printf("%5.2f", change);
    } else {
      newfitness = newfitness + (v2 + v3) * (1.0 - ((v3 - v2) / 8.0)) * (1.0 - (sensormaxactivity)); // Need to add something to sensor
      //change = (v2+v3)*(1.0-((v3-v2)/8.0))*(1.0-(sensormaxactivity));
      //printf("%5.2f", change);
    }
  } else if ((dirL == 1 || dirR == 1) && collision == 0) {
    newfitness = newfitness + 0;
    //printf("YES\n\r");
  } else if (collision == 1) {
    newfitness = newfitness + 0;
    //printf("NO\n\r");
  }
}

////////////////////////////////////////////////////////////////
void updateLeftMotor(void) {
  // Left Motor
  // Stepper Motor moves 7.5 degree per step, so 48 steps / rev (360 / 7.5). Circumference of wheel is 15.9593 cm / rev (2 inch * 2.54 cm/ in * pi / 2).
  // Velocity = 15.9593 cm / rev * 1/48 rev / (t2 / 1000 s) = .332485 cm / (t2/1000 s)
  // Wire Configuration: Orange to C.0, Yellow to C.1, Brown to C.2, Black to C.3, Red and Green to 12V
  // if (stepL == 3) PORTC = (PORTC & 0b11110000) | 1;
  // if (stepL == 2) PORTC = (PORTC & 0b11110000) | 4;
  // if (stepL == 1) PORTC = (PORTC & 0b11110000) | 2;
  // if (stepL == 0) PORTC = (PORTC & 0b11110000) | 8;
  if (dirL) // 0 is forward, 1 is backward
  {
    printf("left: forward\n");
  } else {
    printf("left: backward\n");
  }
}

////////////////////////////////////////////////////////////////
void updateRightMotor(void) {
  // Right Motor
  // Stepper Motor moves 7.5 degree per step, so 48 steps / rev (360 / 7.5). Circumference of wheel is 15.9593 cm / rev (2 inch * 2.54 cm/ in * pi / 2).
  // Velocity = 15.9593 cm / rev * 1/48 rev / (t2 / 1000 s) = .332485 cm / (t3/1000 s)
  // Wire Configuration: Orange to C.4, Yellow to C.5, Brown to C.6, Black to C.7, Red and Green to 12V
  // if (stepR == 3) PORTC = (PORTC & 0b00001111) | 16;
  // if (stepR == 2) PORTC = (PORTC & 0b00001111) | 64;
  // if (stepR == 1) PORTC = (PORTC & 0b00001111) | 32;
  // if (stepR == 0) PORTC = (PORTC & 0b00001111) | 128;
  if (dirR) // 0 is forward, 1 is backward
  {
    printf("right: forward\n");
  } else {
    printf("right: backward\n");
  }
}

// Neuron Individual Selection and Mutation
void evolve(void) {
  // Fitness Check - If not greater return to old version in population
  // Debugging
  printf("%i %i %i %i %i %i %7.1f %7.1f %7.1f %7.1f %7.1f %7.1f %7.1f\n\r", individual, threshold[individual], totalspikeFL, totalspikeBL, totalspikeFR, totalspikeBR, newfitness, fitness[0], fitness[1], fitness[2], fitness[3], fitness[4], fitness[5]);

  worstindivid = 0;

  for (z = 1; z < numindivid; z++) // Calculate Worst Individual
  {
    if (fitness[z] < fitness[worstindivid]) {
      worstindivid = z;
    }
  }

  if (newfitness >= fitness[worstindivid] && newfitness >= fitness[individual]) {
    keep = 1;
    fitness[individual] = newfitness;
  } else keep = 0;

  newfitness = 0; // Reset newfitness

  if (keep == 0) {
    signs[individual] = oldsigns;
    for (d = 0; d < numneuron; d++) {
      nconnection[individual][d] = oldnconnection[d];
      sconnection[individual][d] = oldsconnection[d];
    }
    threshold[individual] = oldthreshold;
  }

  // Pick a random individual and mutate it
  individual = (rand() % numindivid);
  // Debugging
  //individual = 0;
  // Save old version
  oldsigns = signs[individual];
  for (e = 0; e < numneuron; e++) {
    oldnconnection[e] = nconnection[individual][e];
    oldsconnection[e] = sconnection[individual][e];
  }
  oldthreshold = threshold[individual];
  // Mutate
  signs[individual] = (signs[individual] ^ (1 << (rand() % numneuron)));
  randn = (rand() % numneuron);
  rands = (rand() % numsensor);
  nconnection[individual][randn] = (nconnection[individual][randn] ^ (1 << (rand() % numneuron)));
  sconnection[individual][rands] = (sconnection[individual][rands] ^ (1 << (rand() % numsensor)));
  threshold[individual] = (threshold[individual] ^ (1 << (rand() % 4)));
  if (threshold[individual] > 6 || threshold[individual] < 2) threshold[individual] = oldthreshold;
  // Send signal
  evolveflag = 1;
  // Debugging
  printf("%i %x %x %x %x\n\r", individual, signs[individual], nconnection[individual][randn], sconnection[individual][rands], sensor);
}

void storeBestFitness(void) {
  // Store Best Fitness Individual in EEPROM
  for (f = 0; f < numindivid; f++) {
    if (fitness[f] >= bestfitness) {
      bestfitness = fitness[f];
      bestindivid = f;
    }
    // Debugging
    //printf("%li\n\r", bestfitness);
  }
  // STORE BEST INDIVID/FITNESS/GENETIC STRING IN EEPROM
  // EEPROM STUFF
  for (ii = 0; ii < numindivid; ii++) {
    // // Save best individual
    // if (ii == bestindivid) {
    //   eebestsigns = signs[ii];
    //   for (zz = 0; zz < numneuron; zz++) {
    //     eebestnconnection[zz] = nconnection[ii][zz];
    //     eebestsconnection[zz] = sconnection[ii][zz];
    //   }
    //   eebestthreshold = threshold[ii];
    //   eebestfitness = fitness[ii];
    // }
    // eesigns[ii] = signs[ii];
    // for (jj = 0; jj < numneuron; jj++) {
    //   eenconnection[ii][jj] = nconnection[ii][jj];
    //   eesconnection[ii][jj] = sconnection[ii][jj];
    // }
    // eefitness[ii] = fitness[ii];
    // eethreshold[ii] = threshold[ii];
  }
  // eebestfitnessmem[eeindex] = bestfitness;
  // eeindex = eeindex + 1;; // Index of fitness values/replacements
} // Ends task 6

int main() {
  initialize();
  evolve();
  updateSensors();
  updateMotorSpeed();
  updateLeftMotor();
  updateRightMotor();
  storeBestFitness();
}
